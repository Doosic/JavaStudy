더티 체킹(Dirty Checking)이란? (기억보단 기록을(https://jojoldu.tistory.com/415) 참고)
       Spring Data Jpa, ORM 구현체 사용시 더티 체킹이란 단어를 접하게되는데 알아보자

       선행 조건 트랜잭션 적용
       순서
        - 1. 트랜잭션이 시작된다.
          2. 엔티티를 조회한다.
          3. 엔티티의 값을 변경한다.
          4. 트랜잭션을 커밋한다.

       위의 순서대로 실행시 update 메서드를 사용하지 않았으나 update 쿼리가 실행된다.
       그 이유가 Dirty Checking 덕분이다. (Dirty Checking 으로 생성되는 update 쿼리는 기본적으로 모든 필드를 업데이트합니다.)
        - Dirty 란 상태의 변화가 생긴 정도로 이해하면된다.
          즉, Dirty Checking 이란 상태 변경 검사 이다.
       JPA 에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영해준다.
       이때 변화의 기준은 최초의 조회상태이다.

       JPA 에서는 엔티티를 조회하면 해당 엔티티의 조회 상태 그대로 스냅샷을 만들어 놓는다.
       그리고 트랜잭션이 끝나는 시점에는 이 스냅샷과 비교해서 다른점이 있다면 Update Query 를
       데이터베이스로 전달한다.

       당연히 이런 상태 변경 검사의 대상은 영속성 컨텍스트가 관리하는 엔티티에만 적용된다.
            - detach 된 엔티티 (준영속)
            - DB에 반영되기 전 처음 생성된 엔티티(비영속)
       등 준영속/비영속 상태의 엔티티는 Dirty Checking 대상에 포함되지 않는다.

       변경 부분만 Update 하고 싶을땐?
       JPA 에서는 전체 필드를 업데이트하는 방식을 기본값으로 사용한다.
       장점
            - 생성되는 쿼리가 같아 부트 실행시점에 미리 만들어서 재사용 가능하다.
            - 데이터베이스 입장에서 쿼리 재사용이 가능하다
                - 동일한 쿼리를 받으면 이전에 파싱된 쿼리를 재사용한다.

        다만, 필드가 20~30개 이상인 경우엔 이런 전체 필드 Update 쿼리가 부담스러울 수 있다.
            - 사실 필드가 이렇게 많은 경우는 정규화가 잘못된 경우일 확률이 높다고 한다.
              현재 운영중인 정산 서비에스에는 데이터양이나 복잡도가 국내에서 손꼽히지만 15개 넘는
              필드를 가진 테이블이 없다고 한다.
        이런 경우에는 @DynamicUpdate 를 사용하여 변경 필드만 반영되도록 할 수 있다고 한다.